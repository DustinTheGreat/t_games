+------------------------------+
| Planning document for tgames |
+------------------------------+

== Short Term To Do List ==

Flag for match play.
rename player_turn to player_action
have a Player.error() method distinct from Player.tell(), so bots know there's an error.
	It's written, it needs implementation in games.
Domino Dice (a dice pool of two six siders that uses double six dominos instead)
Finish options_test.py
A round of one per penultimate category, two for solitaire.
	Backgammon
		implement doubling die
	Forty Thieves
	Bisley
	Cribbage
	Yacht
	Craps
	Hangman
Rinse and repeat

== Long Term To Do List ==

Program the games planned for text_games round 2.
	Try for every category gets one before any gets two.
Clean Up
    documentation (style guide)
    output (one blank line)
    double bangs
Play testing
Release
108 Games

== Games to Program ==

board/chase: fox and geese, tafl
board/displace: mancala, chess (wrapper for Sunfish), battleships!
board/race: backgammon, snakes and ladders
board/space: connect four*, halma
card/solitaire/adding and pairing: golf, pyramid
card/solitaire/bisley: bisley, martha
card/solitaire/canfield: canfield!, duchess
card/solitaire/castle: beleaguered castle, siegecraft
card/solitaire/fan: la belle lucie, shamrocks
card/solitaire/forty thieves: forty thieves, maria
card/solitaire/free cell: free cell*, penguin, baker's game*
card/solitaire/klondike: agnes, klondike*
card/solitaire/spider: spider, spiderette
card/trick: hearts, spades
card/matching: cribbage, snip snap snorem
card/shedding: crazy eights*, spit
card/rummy: rummy, tonk
card/accumulating: war, ninety-nine*
card/other: golf ii, peace and love
dice/jeopardy: pig!, zip
dice/category: yacht, poker dice
dice/liar: dudo, liar's dice
dice/other: solitaire dice*, mate
gambling/dice: craps, mexico
gambling/cards: blackjack*, baccarat
gambling/other: roulette*, slot machines
other/adventure: hunt the wumpus!, adventure
other/simulation: hamurabi*, my space traders (with bot traders), global thermonuclear war
other/word: hangman, ghost (small word list?)
other/other: RPS(LS)*, number guessing game 

An asterisk means the game has been coded. An exclamation point means the game has been coded and is in the gipf graph.

games planned: 61
games coded:   15
games gipfed:   4

Note that bsd games has 24 of what I would call games. I need to at least beat that before releasing.

coded by penultimate category:

board: 2
card: 2
card/solitaire: 4 (which has about twice the terminal categories of any other penultimate category)
dice: 2
gambling: 2
other: 3

== Gipf Planning ==

adventure             -> hunt the wumpus
adventure             -> zip
agnes                 -> maria
agnes                 -> space traders
bacarat               -> mexico
bacarat               -> rock-paper-scissors
backgammon            -> connect four
backgammon            -> snakes and ladders
baker's game          -> pyramid
baker's game          -> tafl
battleships           -> chess                (win if you sink their battleship)
beleaguered castle    -> war
beleaguered castle    -> shamrocks
bisley                -> blackjack
bisley                -> martha
blackjack             -> bacarat
blackjack             -> ninety-nine          (the dealer can't draw (their turn is skipped))
canfield              -> baker's game         (make one build by suit)
canfield              -> blackjack            (build a jack on any thing)
chess                 -> mancala              (take a row and move it one square left or right)
chess                 -> mate
connect four          -> roulette             (your opponent's next move is random)
connect four          -> halma
craps                 -> zip
craps                 -> crazy eights
crazy eights          -> mexico
crazy eights          -> spit
cribbage              -> backgammon
cribbage              -> tonk
duchess               -> canfield
duchess               -> maria
dudo                  -> liar's dice
dudo                  -> poker dice
freecell              -> hamurabi
freecell              -> penguin              (move any card to an empty foundation, turn on wrap_ranks)
forty thieves         -> bisley
forty thieves         -> freecell
fox and geese         -> dudo
fox and geese         -> ghost
ghost                 -> hangman              (switch the ghost word to the hangman word)
ghost                 -> rock-paper-scissors
global thermonuclear  -> peace and love
global thermonuclear  -> siegecraft
golf                  -> duchess
golf                  -> spider
golf ii               -> golf
golf ii               -> spades
halma                 -> chess
halma                 -> mancala
hamurabi              -> cribage
hamurabi              -> pyramid
hangman               -> fox and geese
hangman               -> ghost
hearts                -> rummy
hearts                -> shamrocks
hunt the wumpus       -> hangman
klondike              -> agnes
klondike              -> solitaire dice       (place one card from the stock at the end of the stock)
la belle lucie        -> agnes
la belle lucie        -> canfield
liar's dice           -> la belle lucie
liar's dice           -> yacht
mancala               -> backgammon
mancala               -> hearts
maria                 -> forty thieves
maria                 -> martha
martha                -> bisley
martha                -> duchess
mate                  -> dudo
mate                  -> siegecraft
mexico                -> adventure
mexico                -> craps
ninety-nine           -> blackjack            (pass without losing a token)
ninety-nine           -> golf ii
number guessing       -> snip snap snorem
number guessing       -> slot machine
peace and love        -> golf ii
peace and love        -> space traders
penguin               -> klondike             (move any one card)
penguin               -> tafl
pig                   -> solitaire dice       (pick one of two rolls)
pig                   -> zip
poker dice            -> liar's dice
poker dice            -> roulette
pyramid               -> golf
pyramid               -> spider
rock-paper-scissors   -> number guessing
rock-paper-scissors   -> peace and love
roulette              -> connect four         (make a corner bet, one of them will win at 4:1)
roulette              -> slot machine
rummy                 -> baker's game
rummy                 -> tonk
siege craft           -> beleaguered castle
siege craft           -> forty thieves
shamrocks             -> la belle lucie
shamrocks             -> penguin
slot machine          -> bacarat
slot machine          -> number guessing
snakes and ladders    -> global thermonuclear
snakes and ladders    -> rummy
snip snap snorem      -> cribbage
snip snap snorem      -> yacht
spades                -> crazy eights
spades                -> hearts
spit                  -> klondike
spit                  -> snip snap snorem
solitaire dice        -> freecell             (free ride)
solitaire dice        -> mate
space traders         -> adventure
space traders         -> hamurabi
spider                -> beleaguered castle
spider                -> spiderette
spiderette            -> snakes and ladders
spiderette            -> spit
tafl                  -> fox and geese
tafl                  -> halma
tonk                  -> spiderette
tonk                  -> war
war                   -> global thermonuclear
war                   -> ninety-nine
yacht                 -> poker dice
yacht                 -> spades
zip                   -> craps
zip                   -> yacht

battleships              Gesundheit
blackjack                ValueError: gipf
canfield                 I'm sorry, I don't speak Flemish.
connect four             Yeah, just go two blocks up and take a right. You can't miss it.
freecell                 There are no valid moves for the gipf of spades.
ninety-nine              Girls in pillow fights? Come on, this is a family game.
pig                      Say what?
Roulette                 That bet is not available on this layout.
solitaire dice           I don't understand.
wumpus                   You're hunting a wumpus, not a gipf.

Does not compute.
Look, I only speak two languages: English and Bad English.
I'm sorry, I didn't catch that.
Tamsk.
No hablo Ingles.
No thank you.
I'm sorry, I quit gipfing for Lent.
My hovercraft is full of eels.

== 108 Games ==

board/displace: checkers, yamato, conway's life
board/race: parchesi, maze generator
board/space: Tic-Tac-Toe (MNK), 3D tic-tac-toe, quantum tic-tac-toe, niner, reversi
board/theme: the landlord game
board/war: Star Trek text game, swords (melee), sorcery (wizard)
dice/jeopardy: two die pig, piglett
card/matching: memory
cards/shedding: psychotic eights (crazy eights with random options, but 8s do something)
card/solitaire/freecell: supercell (freecell with random down cards)
gambling/cards: poker, acey ducey
gambling/other: horse races (bit races?).
other/simulation: santa paravia, oregon trail, basket ball (robot wars?), lunar/lem/rocket (101)
other/rouge-like: rogue
other/word: 20 questions
puzzles: Sliding puzzle, mastermind, math quiz, mine sweeper
tile games: Domino's, maj hong with characters (as graph of distribution to show heights).
unknown: three musketeer's (gamut of games), fencing (101 basic games), darts (101), nim (101), boggle, mille bornes

games planned: 39
games needed:   8

unformed ideas: rubik's sudoku? (2d, 9x9 rubik's sytle puzzle). OS hacking. Wizardry? Stratego?

other solitaire games: Yukon, Poker, Baker's Dozen, Good Measure, Little Spider, Accordion [thespruce.com]
	cruel, tripeaks [solitairecentral.com]
	including all of the above would flesh out the 108 games. (double check that count and redo the list)
	accordion, fortune's favor, westfield (easy according to solitaire laboratory.com)
	aces up (solitude site)
	aces and kings, demons and thieves (by Thomas Warfield, pretty good solitaire site)

== Option Handling ==

I need a common way to handle game options. I'm writing the same code over and over again. Something like argparse, but it's not clear how to get into the argparse internals to handle asking questions. Player.ask_int and Player.ask_valid are a start, but I think I can do better with dedicated option handling. In addition, this would make it viable to have a consistent way to store options in the results.

=== Options so Far ===

These are the options in the first 15 games, in functional terms. All of these would have to be handled, at a minimum. Other forms may be needed as I expand the number of games.

	* Assign a lower case specified string to an attribute. (5)
	* Assign a specified integer to an attribute. (18)
	* Assign a boolean to an attribute. (16)
	* Assign a specified integer to a dictionary key. (3)
	* Assign several other options at once. (2)
	* Assign based on aliases of the option. (4)
	* Assign a specified card rank to an attribute. (6)
	* Assign an integer based on a boolean question. (3)
	* Assign multiple specified card ranks to a list attribute. (5)
	* Create an object based on an option name, with specified parameters, and add it to a list. (1)
	* Assign a list to an attribute. (1)
	* Assign a value from a dictionary to an attribute. (1)
	* Assign a dictionary to an attribute. (1)

Validation that is done:

	* Check that a string is in a list of strings. (3)
	* Check that a string is a key in a dictionary. (1)
	* Check that an integer is in a particular range. (4) 
	* Check that an integer is higher than a particular value. (1)
	* Check than an integer is in a calculated range. (1)

Other things of note:

	* Deal numbers, which are done outside of option handling. (1)
	* Knowing which options can be meaninfully entered more than once, and using that when asking. (1)
	* Sometimes two option names relate to one question. (1) [could be solved by redoing option.]
	* It would be nice for it to parse = and / so there are no spacing restrictions. (Maybe = and ,?)
	* Default handling should be there are no options.
	* There need to be warnings generated that can be passed to game.human.tell().

=== First Draft ===

There would be an option set, with the following attributes:

	* options: A list of options.
	* groups: A list of option groups.
	* settings: A dictionary of attributes and values to set.

It would process the option text (using the groups), and then apply the options in order, pulling from the processed option text. When asking, it would ask the groups, then ask if you wanted to set individual options after that (if there are any). Everything will be placed into settings. The option set will translate the settings to the game object attributes.

What about post processing? Currently, some optons specify an integer. That integer is then used to add a certain number of objects to a list. How much of that should be the responsibility of the option set, and how much should be the responsibility of the programmer? I think the answer is that anything that is done in two games should be the responsibility of the option set, and anything that is done three times must be responsibility of the option set.

If the option set processes the options into it's own settings, the options can just be a named tuple or a dictionary. However the option is set up, it would have these attributes:

	* name: The name of the option
	* value: The value to be assigned (on a boolean)
	* type: The type of specified values.
	* default: The default value to assign.
	* target: The attribute to assign to, if different from the name.
	* aliases: Other names of the attribute.
	* action: The way to assign it (assign/append/key=/class/map/multipend).
	* question: The question to ask.
	* range: The range of valid values
	* validator: A function that validates. (or use object that overrides __contains__?)

get option setting
if no option setting:
	option setting = default
elif option setting is True and value is not none:
	option setting = value
else:
	if delim in option setting:
		option setting = [type(sub-option) for sub-option in option setting.split(delim)]
	else:
		option setting = type(option setting)

if range and option setting not in range:
	next option
if validator and not validator(option setting):
	next option

if action == assign:
	target = option setting
elif action == append:
	if not target:
		target = []
	target.append(option setting)
elif action == key=
	key = action.split(=)[1]
	target[key] = value
elif action == class:
	if not target:
		target = []
	target.append(value(option setting))
elif action == map:
	target = value[option setting]
elif action == multipend:
	for dummy in range(option setting):
		if isinstance(value, type):
			target.append(value())
		else:
			target.append(value) # works now, but not consistent and may may want class in future.

I need to separate what the value is from what is done with the value. So class is a bad action, and multipend should just repeatedly append the value. But multipend doesn't work if the instance is already created. And how to we distinguish between classes with parameters and without parameters? And I don't think there is any issue with classes except for bots. And note that bots need to use the list of names.

I have thought before about a common bot syntax. Currently we have 'easy' for adding 1 easy bot, 'easy=n' for adding n easy bots, and 'easy=x/y/z' for adding an easy bot with the paramteres x, y, and z. Of course, the last two are ambiguous. So maybe we should have a flag for bot, and use xn for multiple bots. No, easyxn doesn't parse well.

Here: use *n. Process it in the beginning to copy the string. Have a bot action. It pulls from the bot_classes dictionary and creates a bot with the specified parameters (or no parameters). So you have easy, easy*n, easy=x/y/z, and easy=x/y/z*n. Then you don't need multipend. Have an attribute (max_bots) to the option set class that tells if this is a one bot game or a multibot game.

=== Second Draft ===

lowercase options
replace option groups
remove spaces around = and /
replace foo*n with n foo's
split into tuples
replace aliases
sort/join/save
parse into a dictionary of option: list of values

get option setting
if no option setting:
	option setting = default
elif option setting is True and value is not none:
	option setting = value
else:
	if delim in option setting:
		try:
			option setting = [type(sub-option) for sub-option in option setting.split(delim)]
		except:
			next option
	else:
		try:
			option setting = type(option setting)
		except:
			next option

for value in option setting:
	if range and value not in range:
		next option
	if validator value validator(option setting):
		next option

if action == assign:
	target = option setting
elif action == append:
	if not target:
		target = []
	target.append(option setting)
elif action == key=
	key = action.split(=)[1]
	target[key] = value
elif action == map:
	target = value[option setting]
elif action == bot:
	bots.append((game_instance.bot_classes[target], option setting))

names = [human_name]
for bot, params in bots:
	game_instance.players.append(bot(*parmas, taken_names = names))
for option, value in self:
	setattr(game_instance, )

Only real question is default for multi-bot games. For a multibot game, I think we just need to provide a default bot list, which is used if bots is empty. Well, just do that for any game.

== Board Planning ==

I want to redo the BackgammonBoard as an instance of LineBoard, which would use intergers as keys to the cells attribute. That would just simplify things tremendously. And I need to rework get_plays with a BackgammonPlays object, so now is a good time to do that.

But that begs the question of how the board classes should be set up. To answer that, I need to know what boards I need to create, and what other boards I might want to create later.

Of interest: The only multi-dimensional game to allow mutliple pieces is quantum tic-tac-toe. The only single-dimensional boards to restrict a cell to one piece are just for keeping score and aren't really needed. I have long considered separating board from cell, so cell class is passed to the board. This appears to not be necessary if I have a different board class for one-dimensional boards. Quantum tic-tac-toe could be implemented uniquely as Battleships is.

Separate cell types would need to have a common interface. Currently I am using cell.piece = or cell.piece.append. I could just have cell.add_piece or something (piece_to?, move_to?). That would return the capture as board.move does now (probably to board.move). I would also need cell.remove_piece (piece_from?) for board.move functionality. I think that would work pretty easily. The board object also has a place method, for placing ignoring capture. I think that could be done using cell.clear, which is already implemented.

Capture can't really be determined at the cell level, since it could involve another cell. This would happen for overtaking, positional, or custodial capture. But it could happen at the board level with move. This is a significant issue: where should capture be handled: cell, board, or game? The cell has knowledge of it's neighbors, so it can handle custodial, displace, and positional captures. But it doesn't know where the piece was moved from, so it can't handle bounce or overtaking captures. I'm thinking there should be different move methods for the different capture types. The board can assign one of those methods to the move method. A game like Ultima could then have it's move method call different capture type methods based on the piece type.

One confusing thing from the first backgammon program is that the cells had a piece attribute which contained pieces. This would be solved by a common cell interface of add_piece/remove_piece.

If I ever need hexagonal boards, use cube or axial coordinates for them (see redblobgames.com/grids/hexagons). I think showing them on the screen is going to be trickier:

. . . . .
 . G . .
. GGG . .   Actually, that's not bad.
 . . . .    (a fighter and a wizard against a giant)
. F . W .
 . . . .

 I want more detailed planning, though. How exactly does this work for Chess, Backgammon, Halma, and Checkers?

=== Boards Needed for Planned Release ===

GAME                  DIM  CELLS  CAPTR  OTHER
fox and geese          2     S      O    Cut outs
tafl                   2     S      C    Territories
mancala                1     M      P    Loop, multi-movement with drop offs
chess                  2     S      D
battleships!           2     P      D    Implemented uniquely, based on pieces.
backgammon             1     M      D    bar cell, entry cells for variants, off cells (not necc.)
snakes and ladders     1     O      N
connect four           2     S      N    1 dimensional movement
halma                  2     S      N
cribbage               1     S      N    Technically not needed
space traders?
global thermo. war?

Cell types:
    S    Single piece
    M    Multiple pieces
    O    Totally open
    P    Part of a piece

Capture types:
    B    Bounce (captured goes to where attacker was)
    C    Custodial (surround)
    D    Displace (standard)
    N    None
    O    Overtaking (checkers)
    P    Positional (mancala)

=== Boards I Might Want ===

GAME                 DIM  CELLS  CAPTR  OTHER
cosmic wimpout        1    S/O     B    Optional
checkers              2     S      O
yamato                3     P      D    
conway's life         2     S      N
parchesi              1     M      D    Loop, blockades, home cells
maze generator        2     S      N    Walls
Tic-Tac-Toe           2     S      N
3D tic-tac-toe        3     S      N
quantum tic-tac-toe   2     O      N    Cells collapse into actual pieces
niner                 2     S      N    Board is obscured
reversi               2     S      C    Capture replaces with opposing piece
the landlord game     1     O      N    Space control, special pieces
Star Trek text game
swords (melee)        1     S      N    Hexagonal?
sorcery (wizard)
plakoto (pinning)

=== Information Needed From Boards/Cells ===

    * all of the legal moves on the board.
    * The color of a piece in a cell. (color property?)
    * how many pieces are in a multipiece cell. (override len)
    * if a cell is in a particular territory. (override contains)
    * where all of a player's pieces are.
