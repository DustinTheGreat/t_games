+------------------------------+
| Planning document for tgames |
+------------------------------+

== Short Term To Do List ==

Finish options_test.py
redo Baker's Game as a variant of FreeCell.
title to menu so you know what category you're in.
	top command to get to the top of the menu.
A round of one per penultimate category, two for solitaire.
	Cribbage (tricky strategy)
	Craps (complicated play, street vs. casino)
	Hangman (word list)
	Backgammon
		read up on backgammon strategy
		try (once) to make a better bot
		gipf
		variants
Rinse and repeat

== Long Term To Do List ==

Program the games planned for text_games round 2.
	Try for every category gets one before any gets two.
	Shoot for at least 25 before releasing (to beat bsdgames)
		try to have a connected gipf grapf
		or at least a spanning path.
		Note that after the current section is done, going by the gipf growth plan (below) does this.
		Also note that I could just redo the gipf graph to get what I want. Duh.
Clean Up
    documentation (style guide)
    output (one blank line)
    double bangs
Play testing
Release
108 Games

== Games to Program ==

board/chase: fox and geese, tafl
board/displace: mancala, chess (wrapper for Sunfish), battleships!
board/race: backgammon, snakes and ladders
board/space: connect four*, halma
card/solitaire/open/sorters: crescent, black hole
card/solitaire/open/builders: bisley, beleagured castle, free cell*
card/solitaire/open/other: pyramid, nestor
card/solitaire/hybrid/sorters: interregnum, labyrinth, strategy
card/solitaire/hybrid/builders: martha, la belle lucie, spider
card/solitaire/closed/sorters: golf, quadrille
card/solitaire/closed/builders: canfield*, forty thieves*, klondike*
card/solitaire/closed/other: monte carlo, accordion
card/trick: hearts, spades
card/matching: cribbage, snip snap snorem
card/shedding: crazy eights*, spit
card/rummy: rummy, tonk
card/accumulating: war, ninety-nine*
card/other: golf ii, peace and love
dice/jeopardy: pig!, zip
dice/category: yacht, poker dice
dice/liar: dudo, liar's dice
dice/other: solitaire dice*, mate
gambling/dice: craps, mexico
gambling/cards: blackjack*, baccarat
gambling/other: roulette*, slot machines
other/adventure: hunt the wumpus!, adventure
other/simulation: hamurabi*, my space traders (with bot traders), global thermonuclear war
other/word: hangman, ghost (small word list?)
other/other: RPS(LS)*, number guessing game 

An asterisk means the game has been coded. An exclamation point means the game has been coded and is in the gipf graph.

games planned: 63
games coded:   17

Note that bsd games has 24 of what I would call games. I need to at least beat that before releasing.

coded by penultimate category:

board: 2
card: 2
card/solitaire: 4 (which has about twice the terminal categories of any other penultimate category)
dice: 2
gambling: 2
other: 3

== Gipf Planning ==

accordion             -> spit
accordion             -> canfield
adventure             -> hunt the wumpus
adventure             -> zip
bacarat               -> mexico
bacarat               -> rock-paper-scissors
backgammon            -> connect four
backgammon            -> snakes and ladders
battleships           -> chess                (win if you sink their battleship)
battleships           -> 
beleaguered castle    -> war
beleaguered castle    -> forty thieves
bisley                -> blackjack
bisley                -> martha
black hole            -> space traders
black hole            -> interregnum
blackjack             -> bacarat
blackjack             -> ninety-nine          (the dealer can't draw (their turn is skipped))
canfield              -> la belle lucie
canfield              -> blackjack            (build a jack on any thing)
chess                 -> mancala              (take a row and move it one square left or right)
chess                 -> mate
connect four          -> roulette             (your opponent's next move is random)
connect four          -> halma
craps                 -> zip
craps                 -> crazy eights
crazy eights          -> mexico
crazy eights          -> spit
crescent              -> tafl
crescent              -> beleaguered castle
cribbage              -> backgammon
cribbage              -> tonk
dudo                  -> liar's dice
dudo                  -> poker dice
freecell              -> hamurabi
freecell              -> nestor
forty thieves         -> bisley
forty thieves         -> freecell             (move any one card from the waste)
fox and geese         -> dudo
fox and geese         -> ghost
ghost                 -> hangman              (switch the ghost word to the hangman word)
ghost                 -> rock-paper-scissors
global thermonuclear  -> peace and love
global thermonuclear  -> forty thieves
golf                  -> black hole
golf                  -> spider
golf ii               -> golf
golf ii               -> spades
halma                 -> chess
halma                 -> mancala
hamurabi              -> cribbage
hamurabi              -> pyramid
hangman               -> fox and geese
hangman               -> ghost
hearts                -> rummy
hearts                -> strategy
hunt the wumpus       -> hangman
hunt the wumpus       ->
interregnum           -> martha
interregnum           -> labyrinth
klondike              -> quadrille
klondike              -> solitaire dice       (place one card from the stock at the end of the stock)
la belle lucie        -> black hole
la belle lucie        -> canfield
labyrinth             -> tafl
labyrinth             -> interregnum
liar's dice           -> la belle lucie
liar's dice           -> yacht
mancala               -> backgammon
mancala               -> hearts
martha                -> bisley
martha                -> nestor
mate                  -> dudo
mate                  -> monte carlo
mexico                -> adventure
mexico                -> craps
monte carlo           -> pyramid
monte carlo           -> strategy
nestor                -> crescent
nestor                -> monte carlo
ninety-nine           -> blackjack            (pass without losing a token)
ninety-nine           -> golf ii
number guessing       -> snip snap snorem
number guessing       -> slot machine
peace and love        -> golf ii
peace and love        -> space traders
pig                   -> solitaire dice       (pick one of two rolls)
pig                   -> zip
poker dice            -> liar's dice
poker dice            -> roulette
pyramid               -> golf
pyramid               -> spider
quadrille             -> accordion
quadrille             -> crescent
rock-paper-scissors   -> number guessing
rock-paper-scissors   -> peace and love
roulette              -> connect four         (make a corner bet, one of them will win at 4:1)
roulette              -> slot machine
rummy                 -> klondike
rummy                 -> tonk
slot machine          -> bacarat
slot machine          -> number guessing
snakes and ladders    -> global thermonuclear
snakes and ladders    -> rummy
snip snap snorem      -> cribbage
snip snap snorem      -> yacht
spades                -> crazy eights
spades                -> hearts
spit                  -> klondike
spit                  -> snip snap snorem
solitaire dice        -> freecell             (free ride)
solitaire dice        -> mate
space traders         -> adventure
space traders         -> hamurabi
spider                -> beleaguered castle
spider                -> labyrinth
strategy              -> snakes and ladders
strategy              -> quadrille
tafl                  -> fox and geese
tafl                  -> halma
tonk                  -> accordion
tonk                  -> war
war                   -> global thermonuclear
war                   -> ninety-nine
yacht                 -> poker dice
yacht                 -> spades
zip                   -> craps
zip                   -> yacht

battleships              Gesundheit
blackjack                ValueError: gipf
canfield                 I'm sorry, I don't speak Flemish.
connect four             Yeah, just go two blocks up and take a right. You can't miss it.
freecell                 There are no valid moves for the gipf of spades.
ninety-nine              Girls in pillow fights? Come on, this is a family game.
pig                      Say what?
Roulette                 That bet is not available on this layout.
solitaire dice           I don't understand.
wumpus                   You're hunting a wumpus, not a gipf.

Does not compute.
Look, I only speak two languages: English and Bad English.
I'm sorry, I didn't catch that.
Tamsk.
No hablo Ingles.
No thank you.
I'm sorry, I quit gipfing for Lent.
My hovercraft is full of eels.

== 108 Games ==

board/displace: checkers, yamato, conway's life
board/race: parchesi, maze generator
board/space: Tic-Tac-Toe (MNK), 3D tic-tac-toe, quantum tic-tac-toe, niner, reversi
board/theme: the landlord game
board/war: Star Trek text game, swords (melee), sorcery (wizard)
dice/jeopardy: two die pig, piglett
card/matching: memory
cards/shedding: psychotic eights (crazy eights with random options, but 8s do something)
card/solitaire: strategy, terrace, bouquet
gambling/cards: poker, acey ducey
gambling/other: horse races (bit races?).
other/simulation: santa paravia, oregon trail, basket ball (robot wars?), lunar/lem/rocket (101)
other/rouge-like: rogue
other/word: 20 questions
puzzles: Sliding puzzle, mastermind, math quiz, mine sweeper
tile games: Domino's, maj hong with characters (as graph of distribution to show heights).
unknown: three musketeer's (gamut of games), fencing (101 basic games), darts (101), nim (101), boggle, mille bornes

games planned: 41
games needed:   6

unformed ideas: rubik's sudoku? (2d, 9x9 rubik's sytle puzzle). OS hacking. Wizardry? Stratego? Coder (themed board game, start in high school, have to get cards/points to graduate, then under grad, and grad school, and work. You can skip to work after any graduation, but winning work is easier with more education, and work may send you back to school (obsolete card/space). Same track, but different card piles?),

other solitaire games: Yukon, Poker, Baker's Dozen, Good Measure, Little Spider, Accordion [thespruce.com]
	cruel, tripeaks [solitairecentral.com]
	including all of the above would flesh out the 108 games. (double check that count and redo the list)
	accordion, fortune's favor, westfield (easy according to solitaire laboratory.com)
	aces up (solitude site)
	aces and kings, demons and thieves (by Thomas Warfield, pretty good solitaire site)
	quadrille, sultan, single rail, olga, step-up, monte carlo, interregnum, labyrinth, flip flop, st. helena, crescent, bouquet, kings, striptease. (review of Parlett's Solitaire, picking an interesting one with odds in favor (if possible) from each chapter)

Note that in the current plan for the initial release, there are no games starting with the letters E, J, O, U, V, or X.

== Option Handling ==

I need a common way to handle game options. I'm writing the same code over and over again. Something like argparse, but it's not clear how to get into the argparse internals to handle asking questions. Player.ask_int and Player.ask_valid are a start, but I think I can do better with dedicated option handling. In addition, this would make it viable to have a consistent way to store options in the results.

=== Options so Far ===

These are the options in the first 15 games, in functional terms. All of these would have to be handled, at a minimum. Other forms may be needed as I expand the number of games.

	* Assign a lower case specified string to an attribute. (5)
	* Assign a specified integer to an attribute. (18)
	* Assign a boolean to an attribute. (16)
	* Assign a specified integer to a dictionary key. (3)
	* Assign several other options at once. (2)
	* Assign based on aliases of the option. (4)
	* Assign a specified card rank to an attribute. (6)
	* Assign an integer based on a boolean question. (3)
	* Assign multiple specified card ranks to a list attribute. (5)
	* Create an object based on an option name, with specified parameters, and add it to a list. (1)
	* Assign a list to an attribute. (1)
	* Assign a value from a dictionary to an attribute. (1)
	* Assign a dictionary to an attribute. (1)

Validation that is done:

	* Check that a string is in a list of strings. (3)
	* Check that a string is a key in a dictionary. (1)
	* Check that an integer is in a particular range. (4) 
	* Check that an integer is higher than a particular value. (1)
	* Check than an integer is in a calculated range. (1)

Other things of note:

	* Deal numbers, which are done outside of option handling. (1)
	* Knowing which options can be meaninfully entered more than once, and using that when asking. (1)
	* Sometimes two option names relate to one question. (1) [could be solved by redoing option.]
	* It would be nice for it to parse = and / so there are no spacing restrictions. (Maybe = and ,?)
	* Default handling should be there are no options.
	* There need to be warnings generated that can be passed to game.human.tell().

=== First Draft ===

There would be an option set, with the following attributes:

	* options: A list of options.
	* groups: A list of option groups.
	* settings: A dictionary of attributes and values to set.

It would process the option text (using the groups), and then apply the options in order, pulling from the processed option text. When asking, it would ask the groups, then ask if you wanted to set individual options after that (if there are any). Everything will be placed into settings. The option set will translate the settings to the game object attributes.

What about post processing? Currently, some optons specify an integer. That integer is then used to add a certain number of objects to a list. How much of that should be the responsibility of the option set, and how much should be the responsibility of the programmer? I think the answer is that anything that is done in two games should be the responsibility of the option set, and anything that is done three times must be responsibility of the option set.

If the option set processes the options into it's own settings, the options can just be a named tuple or a dictionary. However the option is set up, it would have these attributes:

	* name: The name of the option
	* value: The value to be assigned (on a boolean)
	* type: The type of specified values.
	* default: The default value to assign.
	* target: The attribute to assign to, if different from the name.
	* aliases: Other names of the attribute.
	* action: The way to assign it (assign/append/key=/class/map/multipend).
	* question: The question to ask.
	* range: The range of valid values
	* validator: A function that validates. (or use object that overrides __contains__?)

get option setting
if no option setting:
	option setting = default
elif option setting is True and value is not none:
	option setting = value
else:
	if delim in option setting:
		option setting = [type(sub-option) for sub-option in option setting.split(delim)]
	else:
		option setting = type(option setting)

if range and option setting not in range:
	next option
if validator and not validator(option setting):
	next option

if action == assign:
	target = option setting
elif action == append:
	if not target:
		target = []
	target.append(option setting)
elif action == key=
	key = action.split(=)[1]
	target[key] = value
elif action == class:
	if not target:
		target = []
	target.append(value(option setting))
elif action == map:
	target = value[option setting]
elif action == multipend:
	for dummy in range(option setting):
		if isinstance(value, type):
			target.append(value())
		else:
			target.append(value) # works now, but not consistent and may may want class in future.

I need to separate what the value is from what is done with the value. So class is a bad action, and multipend should just repeatedly append the value. But multipend doesn't work if the instance is already created. And how to we distinguish between classes with parameters and without parameters? And I don't think there is any issue with classes except for bots. And note that bots need to use the list of names.

I have thought before about a common bot syntax. Currently we have 'easy' for adding 1 easy bot, 'easy=n' for adding n easy bots, and 'easy=x/y/z' for adding an easy bot with the paramteres x, y, and z. Of course, the last two are ambiguous. So maybe we should have a flag for bot, and use xn for multiple bots. No, easyxn doesn't parse well.

Here: use *n. Process it in the beginning to copy the string. Have a bot action. It pulls from the bot_classes dictionary and creates a bot with the specified parameters (or no parameters). So you have easy, easy*n, easy=x/y/z, and easy=x/y/z*n. Then you don't need multipend. Have an attribute (max_bots) to the option set class that tells if this is a one bot game or a multibot game.

=== Second Draft ===

lowercase options
replace option groups
remove spaces around = and /
replace foo*n with n foo's
split into tuples
replace aliases
sort/join/save
parse into a dictionary of option: list of values

get option setting
if no option setting:
	option setting = default
elif option setting is True and value is not none:
	option setting = value
else:
	if delim in option setting:
		try:
			option setting = [type(sub-option) for sub-option in option setting.split(delim)]
		except:
			next option
	else:
		try:
			option setting = type(option setting)
		except:
			next option

for value in option setting:
	if range and value not in range:
		next option
	if validator value validator(option setting):
		next option

if action == assign:
	target = option setting
elif action == append:
	if not target:
		target = []
	target.append(option setting)
elif action == key=
	key = action.split(=)[1]
	target[key] = value
elif action == map:
	target = value[option setting]
elif action == bot:
	bots.append((game_instance.bot_classes[target], option setting))

names = [human_name]
for bot, params in bots:
	game_instance.players.append(bot(*parmas, taken_names = names))
for option, value in self:
	setattr(game_instance, )

Only real question is default for multi-bot games. For a multibot game, I think we just need to provide a default bot list, which is used if bots is empty. Well, just do that for any game.

== Board Planning ==

I want to redo the BackgammonBoard as an instance of LineBoard, which would use intergers as keys to the cells attribute. That would just simplify things tremendously. And I need to rework get_plays with a BackgammonPlays object, so now is a good time to do that.

But that begs the question of how the board classes should be set up. To answer that, I need to know what boards I need to create, and what other boards I might want to create later.

Of interest: The only multi-dimensional game to allow mutliple pieces is quantum tic-tac-toe. The only single-dimensional boards to restrict a cell to one piece are just for keeping score and aren't really needed. I have long considered separating board from cell, so cell class is passed to the board. This appears to not be necessary if I have a different board class for one-dimensional boards. Quantum tic-tac-toe could be implemented uniquely as Battleships is.

Separate cell types would need to have a common interface. Currently I am using cell.piece = or cell.piece.append. I could just have cell.add_piece or something (piece_to?, move_to?). That would return the capture as board.move does now (probably to board.move). I would also need cell.remove_piece (piece_from?) for board.move functionality. I think that would work pretty easily. The board object also has a place method, for placing ignoring capture. I think that could be done using cell.clear, which is already implemented.

Capture can't really be determined at the cell level, since it could involve another cell. This would happen for overtaking, positional, or custodial capture. But it could happen at the board level with move. This is a significant issue: where should capture be handled: cell, board, or game? The cell has knowledge of it's neighbors, so it can handle custodial, displace, and positional captures. But it doesn't know where the piece was moved from, so it can't handle bounce or overtaking captures. I'm thinking there should be different move methods for the different capture types. The board can assign one of those methods to the move method. A game like Ultima could then have it's move method call different capture type methods based on the piece type.

One confusing thing from the first backgammon program is that the cells had a piece attribute which contained pieces. This would be solved by a common cell interface of add_piece/remove_piece.

If I ever need hexagonal boards, use cube or axial coordinates for them (see redblobgames.com/grids/hexagons). I think showing them on the screen is going to be trickier:

. . . . .
 . G . .
. GGG . .   Actually, that's not bad.
 . . . .    (a fighter and a wizard against a giant)
. F . W .
 . . . .

 I want more detailed planning, though. How exactly does this work for Chess, Backgammon, Halma, and Checkers?

=== Boards Needed for Planned Release ===

GAME                  DIM  CELLS  CAPTR  OTHER
fox and geese          2     S      O    Cut outs
tafl                   2     S      C    Territories
mancala                1     M      P    Loop, multi-movement with drop offs
chess                  2     S      D
battleships!           2     P      D    Implemented uniquely, based on pieces.
backgammon             1     M      D    bar cell, entry cells for variants, off cells (not necc.)
snakes and ladders     1     O      N
connect four           2     S      N    1 dimensional movement
halma                  2     S      N
cribbage               1     S      N    Technically not needed
space traders?
global thermo. war?

Cell types:
    S    Single piece
    M    Multiple pieces
    O    Totally open
    P    Part of a piece

Capture types:
    B    Bounce (captured goes to where attacker was)
    C    Custodial (surround)
    D    Displace (standard)
    N    None
    O    Overtaking (checkers)
    P    Positional (mancala)

=== Boards I Might Want ===

GAME                 DIM  CELLS  CAPTR  OTHER
cosmic wimpout        1    S/O     B    Optional
checkers              2     S      O
yamato                3     P      D    
conway's life         2     S      N
parchesi              1     M      D    Loop, blockades, home cells
maze generator        2     S      N    Walls
Tic-Tac-Toe           2     S      N
3D tic-tac-toe        3     S      N
quantum tic-tac-toe   2     O      N    Cells collapse into actual pieces
niner                 2     S      N    Board is obscured
reversi               2     S      C    Capture replaces with opposing piece
the landlord game     1     O      N    Space control, special pieces
Star Trek text game
swords (melee)        1     S      N    Hexagonal?
sorcery (wizard)
plakoto (pinning)

=== Information Needed From Boards/Cells ===

    * all of the legal moves on the board.
    * The color of a piece in a cell. (color property?)
    * how many pieces are in a multipiece cell. (override len)
    * if a cell is in a particular territory. (override contains)
    * where all of a player's pieces are.

== Solitaire Organization ==

I'm using Wikipedia's organzation of solitaire games, but I feel it has it's limitations. It's based on being like one of seven particular games, as if there couldn't be an eighth type of game. David Parlett has a different system of organization, although he does not adhere to it exactly. Could I use the basics of it as a categorization?

=== First Question ===

How do the current games fit into it?

open/sorters: 
open/builders: bisley, beleagured castle, seigecraft~, shamrocks, baker's game, free cell, penguin
open/other: pyramid
hybrid/sorters: 
hybrid/builders: martha, la belle lucie, spider, spiderette
closed/sorters: golf
closed/builders: canfield, duchess, forty thieves, maria~, agnes, klondike
closed/other: 

This is, interestingly, showing directions completely unexplored in my categorization (and the filling out thereof). So I could cut some games, but I would need to add a lot of them as well. This would totally mess up the gipf planning. However, it show the exact weakness I expected in my categorization. I doubt the sorters that I don't have will be similar enough to fit in the current categories.

To quantify the problem: I would need to add eight games, and eleven of the current games are superfluous. I have already picked out some that could be added from the section on 108 games. Some (marked with ~) are really variants of others, and could easily be dropped.

I may want to call 'other' games 'pairers.' It is not clear that that is a universal trait, however. [It appears not to be a universal trait, it's just the most common form of 'other'.]

=== Second Question ===

Can his other categoryies be squeezed into the basics?

Spiders can, he calls them half-open packers (hybrid builders in my scheme).
Blockades appear to be hybrid sorters.
Planners appear to be hybrid sorters as well.

Since he puts them in their own categories, one of each should be included in my final categorization.

=== Proposal ===

open/sorters: crescent, black hole
open/builders: bisley, beleagured castle, shamrocks, free cell, penguin
open/other: pyramid, nestor
hybrid/sorters: interregnum, labyrinth, flip flop
hybrid/builders: martha, la belle lucie, spider
closed/sorters: golf, quadrille
closed/builders: canfield, forty thieves, klondike
closed/other: monte carlo, accordion

ditched: seigecraft~, baker's game, spiderette, duchess, maria~, agnes

That's 22 games, and 6 over the two per category rule. It also does not include his three favorites. I could add strategy in place of flip flop, but his other two favorites are in overfull categories. I could drop penguin and shamrocks to make open/builders more reasonable. That would make it:

open/sorters: crescent, black hole
open/builders: bisley, beleagured castle, free cell
open/other: pyramid, nestor
hybrid/sorters: interregnum, labyrinth, strategy
hybrid/builders: martha, la belle lucie, spider
closed/sorters: golf, quadrille
closed/builders: canfield, forty thieves, klondike
closed/other: monte carlo, accordion

That's 20 games, and 4 over the two per category rule, and none over three per category. I don't lose anything I've already programmed except baker's game (which I can get back as a variant)

== Gipf Growth Plan ==

Or, if I add these games, everything is linked by gipf with no root or leaf nodes:
	bacarat
	zip
	poker dice
	quadrille
	accordion
	spit
	crescent
	beleaguered castle
	number guessing
	slot machine
	(and I would have 32 games for an early release)
	After that these could be added without adding roots or leaves:
		bisley
		nestor
		mexico
		spades
		liar's dice
		tonk
		snip snap snorem
		war
	The next round would be:
		golf ii
		martha
		adventure
		la belle lucie
		global thermonuclear
		(gtw would require adding chess and mancala as well)
		[at this point the gipf digraph would be fully connected.]
	The next round would be:
		halma
		snakes and ladders
		peace and love
	Then:
		tafl
		rummy
		space traders
	then:
		hearts
		black hole
	then:
		golf
		strategy
		interregnum
	then:
		pyramid
		monte carlo
		spider
		labyrinth
	then:
		mate
	then:
		dudo
	then:
		fox and geese
	then:
		hangman * Assumes this was remove from the initial.
		ghost
	And you're done.

=== Relink ===

I could add the following gipf links to the map to have no roots or leaves:
	craps        -> yacht
	crazy eights -> canfield
	crazy eights -> craps
	hangman      -> forty thieves
	hangman      -> rps
	rps          -> klondike
	yacht        -> backgammon
	Then redo those links in the original plan, and then create a plan of rounds just as in the first proposal.
	However, there are still many pairs showing no path. (69%)
		The problem seems to be that battleships, pig, and wumpus are poorly linked out and not linked in.
		battleships -> yacht
		hamurabi    -> wumpus
		ninety-nine -> pig
		klondike    -> battleships
		drops it to 37%, without really messing up the plan.
		I need to map that out visually to find the problems.