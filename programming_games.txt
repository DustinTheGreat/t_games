This documentation is to assist people in writing games for the tgames system. It is not meant to teach you everything about writing games for tgames, just to give you a good overview of what to do. You should also check out the code of some of the games already programmed as well as the base Game class.

== The File ==

The Python (.py) file for the game should be stored in a sub-folder of the tgames folder. Preferably this would be in a folder appropriate for the category of the game. This way if someone wants to find the code for the game, they'll know where to look. Note that the folder structure for tgames generally ignores the terminal category (that is, games in board games/displace games are in the board_games folder with the games in board games/space games). For the same reason, the title of the file should be indicative of the name of the game. The filename must end in '_game.py' or the tgames interface will not load it.

You can create your own folder of games if you want, especially if you are introducing new categories. If you do, you should put in a blank __init__.py file, so that the relative imports work for both Python 2.x and Python 3.x.

== The Class ==

Games are programmed as classes, specifically classes that inherit from game.Game. If your game class does not inherit from Game, it will not be loaded by the interface. The inheritance does not have to be direct. For example, the FreeCell class directly inherits from the Solitaire class, which inherits directly from Game.

The tgames package is based on object orientend programming (OOP). If you are not familiar with OOP and classes in Python, DO NOT WRITE GAMES FOR TGAMES. You will only hurt yourself, and I cannot be held responsible for any resulting medical bills.

=== Attributes ===

There are several class attributes that need to be set, in order for the game to display correctly in the interface.

==== Names ====

The name class attribute is a string that gives the name of the game. This is the name that will be displayed in the menu interface. This should be the name the game is most commonly known by. If your game has other names it is known by, these should go into the aka class attribute, which is a list of strings. Names in the aka list are available for use with the play command from the interface.

Be careful to make the various names of the game unique. The game classes are stored in a dictionary by name. If your game shares a name or aka with another game in the system, one of them will be overwritten by the other one.

==== Rules & Credits ====

Each game class should have two class attributes: rules and credits. These are typically stored as multi-line strings that are module level constants. Then the constant is assigned to the class attribute. That solves any formatting problems with indented multi-line strings.

The rules should clearly describe how to play the game, including any special commands used in the game, and any options for the game (see Methods/handle_options, below). The credits should indicate who invented the game and who programmed the tgames Python implementation (presumably you). If the inventor of the game is not generally known, list it as 'Traditional.' If the game was originally a computer game, credit the person who wrote the original implementation as well.

==== Categories ====

The categories class attribute determines where in the interface menu the game will be displayed. If the game fits in one of the existing categories, put it there (and be sure to spell it correctly). You can create your own categories if you want. The interface will detect them and create them for you.

Note that the categories class attribute is a list of strings. The first item is the top category, then the sub-category, and then the sub-sub-category, if any.

==== Number of Options ====

The num_options attribute should reflect the number of settable options. It defaults to 0. Note that options which basically affect the same thing should count as one option. So if you have easy, medium, and hard options for setting the strength of the bot, those three count as one option.

==== Help ====

If you want to provide additional help text beyond the rules it would go in the help class attribute. This is not common, but you can make use of it if you want.

The help class attribute is a dictionary of help text keyed to help categories. If the user types 'help foo', whatever text is in self.help['foo'] is displayed.

=== Methods ===

You will need to override the player_turn and game_over methods to make your game work. In most cases, you will want to override set_up as well. If you game has options that can be set before play, you will need to override the set_options method. You may also want to create do_foo methods, and override the default method.

The way the program flows through these methods is as follows: When the game class is initialized, the set_options method is called to define the options, and the handle_options method is called to process any options given from the interface, and to give the user a chance to enter in the options if they were not provided through the interface. Then the play method is called, which calls the set_up method. This sets up the game, initializing any game components. Most importantly, this is where the list of players is set up. Then the players are rotated through, calling player_turn for each one in turn. This is where the player move is obtained and processed. The player_turn may (and should) call handle_cmd to process any commands with a do_foo method, or the default method if the command is not recognized. Note that player_turn is called repeatedly until it returns False. Then game_over is called, and if it returns False, player_turn is called for the next player in order. If game_over returns True, the game is over and results are returned from the play method to the interface. The interface will then ask if the user wants to play the same game again. If they do, play is called again, calling set_up again and cycling through player_turn again. Note that handle_options is not called again at that point. So things that can be set and used over several plays of the game should be processed in handle_options, but things that need to be reset every time the game is played should be handled in set_up.

When interacting with players, you should use the player.ask method in place of the input function, and the player.tell method in place of the print function. There are interface features in those methods that will be lost if you use plain input or print. When designing computer players (bots), you should use the ask and tell methods and the same prompts/text as the human player gets to determine where the bot is in the game sequence. Note that bots have a game method, which provides direct access to the game class instance. This will allow them to access the computer implementations of the scores and board and other game features for making decisions.

==== set_up ===

This sets up whatever is needed to play the game, and is not already handled by the base Game class. If you have a game board or a deck of cards to keep track of, here is where you would set them up.

The players attribute, which is a list of Player sub-class instances, should be ready when set_up is over. It doesn't need to be done in set_up. You might set that up in handle_options, if the player can choose the bots to play against. Note that there is a human attribute of the game instance if you need to pull the user into the player list. You will have to keep track of the bots yourself. 

You will want to order the players here, unless you want the same order if the user choses to play again. Note that the player scores are not reset until after set_up is called. That way you can use the scores from the previous games to order the players for the current game. Pig does this so that the loser of the previous game goes first.

In any case, remember that set_up is called before each game, while handle_options is called only when the game object is initialized by the interface.

==== player_turn ====

This is where the meat of your game is going to happen. This is where you will ask the player for their move and process that move.  The current player is passed as the player parameter to this function. Use the player.ask method to get a move from them, and the player.tell method to send the results of the move to them.

The return value for player_turn is a flag for continuing the turn. That is, if player_turn returns True, player_turns is called again with the SAME player, and without incrementing the turns attribute of the game class, that tracks how many player turns have been completed. If player_turn returns False, that player's turn ends, the turns attribute is incremented, the game_over method is checked. If game_over returns False, player_turn is called again with the next player in the players attribute.

The player.ask method returns a string, and you can process that string however you want. However, if the response from the player is not a valid move, you should send it to the handle_cmd method, and you should return the result of the handle_cmd method. This will process any commands that are common to all games, such as rules, rpn, and quit. Note that if the response from the player is not recognized by handle_cmd, it gets sent to the default method. You can override that to handle anything that your processing does not recognize. For example, the Solitaire class overrides default so that if a player enters a card without stating what they want to do with it, the game class can guess what move they intended.

You can have handle_cmd deal with the whole game. The handle_cmd method takes the first word of the player's response, finds a do_foo method for that word, and passes the rest of the player's response to that method. For example, if the player types in 'kill the orc', handle_cmd will look for a do_kill method. If do_kill exists, handle_cmd will call self.do_kill('the orc'). If do_kill does not exist, handle_cmd will call self.default('kill the orc'). So you can create do_foo methods to handle the various moves the player might make. The Solitaire class does exactly that.

Resist creating a loop in player_turn to handle multiple parts of a player's turn. That will interfere with the processing of other commmands, like quit. The player_turn method is already being called in a loop, as long as it returns False. Make use of that loop.

Making use of the player_turn loop or do_foo methods will require creating instances attributes. Be sure to check the doc_string for the Game class (and the Solitaire class if you are making a solitaire game) so that you do not overwrite any attributes already being used. Instance attributes tracking the player's turn are also useful for bots. They can access them through their game attribute, which is easier than having them parse information from strings sent to player.tell.

You should set the score for the player at the end of each turn. If the player calls the quit command, the game will end without going through game_over. So you want the score to be ready if that happens. The scores attribute is a dictionary of player scores, keyed to their names. So self.scores[player.name] will give you the current player's score.

==== game_over ====

The game_over method is called at the end of each player's turn (when player_turn returns False). It should return True if the game is over, and it should return False if the game should continue. 

It should also set the win_loss_draw attribute of the game instance. That attribute is per player from the perspective of the human, and is a list of three integers. The first integer is how many players the human did better than, the second is how many players the human did worse than, and the third is how many players the human did the same as. Generally this would be based on the the scores attribute, but it should be whatever the game rules dictate. So if a player wins against three bots, it would be [0, 3, 0]. If he beats one bot but loses to the other two, it would be [1, 2, 0]. If he ties for first, it would be [2, 0, 1]. The interface counts the game as a win if the second number in win_loss_draw is 0.

==== handle_options ====

This menu processes any options for the game based on the OptionSet defined in set_options. You generally don't want to override this, unless you want to completely override how options are handled. If you want to do some post option processing, you can either do that in set_up (which will do it each time the game is played), or you can use super to call the parent class handle_options, and then do the necessary processing.

If raw_options.lower() == 'none', the default options will be applied. If raw_options is empty, handle_options will ask the user questions to determine the option settings. Otherwise, it will process the option settings given in raw_options.

If you do override handle_options, and the player changes the options, either from the interface or by answering questions, you need to adjust the flags attribute of the game. You should do 'self.flags |= 1' to indicate that options were changed for the game.

==== do_gipf ====

Gipf is the first game in a series by Kris Burm. In that series of games you have potential moves. If you make a potential move, your opponent can challenge the move. The challenge is decided by playing one of the other games in the series.

That concept has been brought into the tgames system as the gipf command. For each game there are two or more games you can gipf to. If you win the game you gipf to, you can make a special move in the game you gipfed from. Generally there are different special moves for different games.

You can program this into your games if you want. There is a gipf_check method of the game class that is useful for adding gipf to your game. You pass it the arguments of the gipf command (the arguments parameter of do_gipf), and a tuple of names of games that can be gipfed to. It will handle finding the game based on names or aliases, running the game, and setting the flags attributes of both games. It will return which game was played (using the same name or alias you provided as a parameter) and how many player-to-player losses there were. Then you determine which game they chose and whether or not they won, and if they won a valid game let them make a special move.

Note that if they don't choose a valid game, you should give a non-sequitor or confused response to the user. The exact response should be unique to your game.

==== set_options ====

The set_option method defines the options availble for the game, for later use by handle_options. The options are stored and handled by a options.OptionSet instance, stored in the option_set attribute of the game. Each option in the OptionSet is stored as a dictionary of values. These are created using the add_option method of the OptionSet.

For example, take the even-turns option in Pig. If that option is True, each player gets the same number of turns before the game is over. The simplest way to set that up would be: self.option_set.add_option(name = 'even-turns', target = 'even_turns'). The name is the name of the option the player would use, and the target is the attribute the option is stored in. The target defaults to the name, but in this case the name uses dashes, where attribute names need underscores. The default behavior for an option definition is to assign True if the option is provided, and False if it is not.

We could reverse this option: call it odd-turns, which assigns False to even_turns if it is provided, and True if it is not. That would be set up with: self.option_set.add_option(name = 'odd-turns', target = 'even_turns', value = False, default = True). The value of the definition is what is assigned if the option is provided, and the default of the definition is what is assigned if the option is not provided. It doesn't have to be True or False, either. For example, the 'six-bad' option to Pig sets the bad attribute to 6, when it is normally one. That attribute is set up as self.option_set.add_option(name = 'six-bad', target = 'bad', value = 6, default = 1).

You often want the user to provide the value of an option, rather than having it be pre-specified. For example, gambling games all have a stake option, to change how much money you have to start. So we want the user to provid a positive integer value. We can do this like so: self.option_set.add_option(name = 'stake', converter = int, check = lambda stake: stake > 0, default = 100). This means that the text value provided by the user would be converted using the built-in int function. Then if it is a valid integer, it is passed to the check function to make sure the value is greater than zero. Note that the default value is specifed as an integer, already converted. You can also specify a valid parameter to add_option, which would be a container with all of the valid choices in it.

One thing that all of the above definitions are missing is a question. If no options are provided, the OptionSet will ask the user what the option settings should be. It needs a question for each option in order to do that. For the stake option to a gambling game, the question would be 'How much money do you want to start with (return for 100 bucks)? '. Note that last bit: if the user just hits return, the default is applied. If there are a lot of options, this allows the user to hit return until they get to the one they want to change.

For the simple options where the user does not provide a value, we want to provide a simple yes/no question. OptionSet will reconginze these questions if you put 'bool' at the end of them. For example, the question for the six-bad option in Pig would be 'Should six be the number that ends the turn without scoring? bool'. Note that 'bool' comes at the very end, after the question mark. Also, note that if you say no to the question, the default of 1 is applied. Always phrase your bool questions so that no means apply the default. Since the answer is treated as 'no' if it is not in utility.YES, this again allows the user to just hit return to get the default.

If the user provides a setting of several values separated by slashes ('/'), those values will be provided as a list. Each item in the list will be run through converter. However, the list as a whole will be checked for existence in valid and passed to the check function.

Here are the details on all of the parameters to the add_option call, which are the values of the dictionary stored in the OptionSet:

	* name: The name of the option. How the option is specified from the menu interface.
	* aliases: A list of other names for the option.
	* converter: A function that returns the option setting in the correct type. Defaults to str. Checks each item in a list setting.
	* default: The default value to assign if the option is not specified by the user. If default is None, no action is taken unless the user provides the option. If default is a list or tuple, the value will be read in as a list.
	* value: The value to provide if the option is given without specifying a setting. If the 'map' action is specified, this should be a dictionary that the values come from. For the 'bot' action, if value is None the user is expected to provide parameters to the bot class. Otherwise, the value for the 'bot' action should be a tuple of parameters to the bot class, to be provided using *args.
	* target: The attribute the setting is to be stored in. Defaults to name. For the 'bot' action, the target is the key to the bot_class dictionary attribute of the game. The value of that key should be a
	subclass of player.Bot.
	* action: The action that is taken with the setting. Recognized actions are:
		* assign: Assign the setting to the attribute.
		* append: Append the setting to the attribute.
		* key=foo: Assign the setting to the foo key of the attribute (target[foo] = setting).
		* map: Uses the setting as a key (of the dictionary store in value) to get the actual setting. That is, target = value[setting].
		* bot: This is a special action described below.
	* question: The question to ask the user if no options are provided from the interface. If the question string ends in 'bool', 'bool' is removed from the question string, and the question is asked a yes/no question. A yes answer applies the value, and no answer applies the default.
	* valid: A list or other container containing all of the valid responses. 'setting in valid' must be True for a setting to be applied. The default for valid is an AllRange object, such that 'foo in AllRange()' is always True. Looks for the full list for list settings.
	* check: A function taking one parameter, that returns True if the parameter is a valid setting. Checks the full list for list settings.
	* error_text: Extra text displayed when a user enters an invalid setting in response to the question.

Bot options are handled through the bot action. For the bot action, the target of the option definition is used as a key for the game's bot_classes attribute. The bot_classes attribute should be a dictionary of string keys with values that subclasses of player.Bot. The setting provided is used as the parameters to create an instance of the bot class. If no setting is provided, the value of the option definiton is checked. If it is True (using the is operator, not the equality operator), the default parameters of the bot class are used. Otherwise the definition's value is used as the parameters for the bot class using *args. If a sequence is provided as a setting, it is used as the parameters for the bot class using *args. Otherwise, the setting is provided as a single parameter to the bot class. Bot classes created this way are appended to game.players.

Bot options should have an default of None. That way, no bot will be added unless the player asks for it. To provide a default set for when the player specifies no bot options, change option_set.default_bots. The default_bots attribute should be a list of tuples. Each of the tuples should have a subclass of player.Bot and a tuple of parameters to be supplied with *args. For example, Pig sets it's options_set.default_bots to [(PigBotBasePaceRace, ())]. This creates a single default bot of the PigBotBasePaceRace class with the default parameters.

Note that bots do not need questions. The questions for bots are generalized and based on their name.

For example, say you have a game named Spam. You have two bot classes for the game, Foo and Bar, and each has two integer parameters defaulting to 2 and 3. You want to allow custom Foo and Bar bots, and three preset bots for easy, medium, and hard (Foo(1, 2), Foo(2, 3), and Bar(2, 3), respectively). The default would be 1 medium bot. Here's how you would set that up:

	* Spam.bot_classes = {'foo': Foo, 'bar': Bar}
	* Spam.option_set.default_bots = [(Foo, (2, 3))]
	* Spam.option_set.add_option, once each with the following parameters:
		* name = 'foo', converter = 'int', check = lambda x: len(x) < 3, default = None
		* name = 'bar', converter = 'int', check = lambda x: len(x) < 3, default = None
		* name = 'easy', converter = 'int', check = lambda x: len(x) < 3, default = None, target = 'foo', value = (1, 2)
		* name = 'medium', converter = 'int', check = lambda x: len(x) < 3, default = None, target = 'foo', value = ()
		* name = 'hard', converter = 'int', check = lambda x: len(x) < 3, default = None, target = 'bar', value = ()

The first one is a class attribute, the rest are done in the set_options method. The converters and the checks make sure no more than two integers are provided as options. The defaults ensure that none of the bots are automatically added every game. The targets on the last three get the right class for the bots. The values on the last three specify the attributes for those bots, with '()' specifying the default attributes.

== Bots ==

If your game is not purely a solitaire game, you will need to create bots to play against. Bots are typically sub-classes of the Bot class in player.py, which is in turn a sub-class of Player. You'll note from the class definition that Bots pick random names for themselves that are not already chosen by another player. You can provide an initial to force the first letter of the name. Some games do this so that it is possible to distinguish which strategy each bot is using. You are free to give your bots other names, but keep in mind that each player (bot or human) should have a unique name. This is necessary because the scores for the game are kept in a dictionary keyed to player name. Also note that your bot will be passed a taken_names parameter during standard option handling.

Your game should not distinguish between humans and bots. For one thing, doing so could mess up tournaments (see the tournament method of the game class). Bots have game attribute which links back to the game instance they are a part of, so they have access to all game information. (Yes, this means that bots can cheat, but it is considered bad form to program them to do so.) Generally, the ask and tell methods are used to tell where in the game flow the bot is, and then the game attribute is used to get information to choose what move to make. Theoretically, you could parse all the information you need from input to the tell method, but the game attribute was provided to remove the need for that.

You'll want to inform the human player of what happens during the bot's turn. This should be done using self.game.human.tell(). If you construct your text well in the game, you can usually just replace 'you' with the bot's name and maybe switch some other pronouns in what comes into the bot's tell method, and then send that to the human's tell method.